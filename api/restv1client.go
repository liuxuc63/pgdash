package api

// This file is autogenerated.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
)

// RestV1Client is a client for RestV1 servers.
type RestV1Client struct {
	base    string
	client  *http.Client
	retries int
}

// NewRestV1Client creates a new client to talk to the specified base URL
// and with the given timeout.
func NewRestV1Client(base string, timeout time.Duration, retries int) *RestV1Client {
	if !strings.HasSuffix(base, "/") {
		base += "/"
	}

	return &RestV1Client{
		base: base,
		client: &http.Client{
			Timeout: timeout,
		},
		retries: retries,
	}
}

func (c *RestV1Client) callOnce(path string, req interface{}, resp interface{}) (retry, wait bool, err error) {
	data, err := json.Marshal(req)
	if err != nil {
		return
	}

	r, err := c.client.Post(c.base+path, "application/json", bytes.NewReader(data))
	if err != nil {
		retry = true
		wait = !strings.Contains(strings.ToLower(err.Error()), "timeout")
		return
	}
	if r.StatusCode/100 == 5 {
		err = fmt.Errorf("server error: %s", r.Status)
		retry = true
		wait = true
		return
	}
	if r.StatusCode/100 != 2 {
		err = fmt.Errorf("client error: %s", r.Status)
		return
	}
	if r.Body == nil {
		err = fmt.Errorf("empty body received")
		return
	}
	defer r.Body.Close()
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return
	}

	err = json.Unmarshal(body, resp)
	return
}

func (c *RestV1Client) call(path string, req interface{}, resp interface{}) error {
	var last error
	for i := 0; i < c.retries; i++ {
		retry, wait, err := c.callOnce(path, req, resp)
		last = err
		if err == nil {
			return nil
		}
		if !retry {
			return err
		}
		if wait {
			time.Sleep(c.client.Timeout)
		}
	}
	return last
}

// Quick calls RestV1.Quick
func (c *RestV1Client) Quick(req ReqQuick) (resp RespQuick, err error) {
	err = c.call("quick", req, &resp)
	return
}
